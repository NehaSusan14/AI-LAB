from heapq import heappush, heappop


GOAL_STATE = ((1, 2, 3),
              (4, 5, 6),
              (7, 8, 0))  

DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]


def heuristic(state):
    
    misplaced = 0
    for i in range(3):
        for j in range(3):
            if state[i][j] != 0 and state[i][j] != GOAL_STATE[i][j]:
                misplaced += 1
    return misplaced


def find_blank(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j


def swap_positions(state, pos1, pos2):
    state_list = [list(row) for row in state]
    r1, c1 = pos1
    r2, c2 = pos2
    state_list[r1][c1], state_list[r2][c2] = state_list[r2][c2], state_list[r1][c1]
    return tuple(tuple(row) for row in state_list)


def get_neighbors(state):
    neighbors = []
    blank_r, blank_c = find_blank(state)

    for dr, dc in DIRECTIONS:
        new_r, new_c = blank_r + dr, blank_c + dc
        if 0 <= new_r < 3 and 0 <= new_c < 3:
            new_state = swap_positions(state, (blank_r, blank_c), (new_r, new_c))
            neighbors.append(new_state)
    return neighbors


def print_state(state):
    for row in state:
        print(' '.join(str(x) if x != 0 else '_' for x in row))
    print()


def a_star(start_state):
    open_set = []
    heappush(open_set, (heuristic(start_state), 0, start_state, []))  # (f, g, state, path)
    visited = set()

    while open_set:
        f, g, current_state, path = heappop(open_set)



        if current_state == GOAL_STATE:
            return path + [current_state]

        if current_state in visited:
            continue
        visited.add(current_state)

        for neighbor in get_neighbors(current_state):
            if neighbor not in visited:
                new_g = g + 1
                new_h = heuristic(neighbor)
                new_f = new_g + new_h
                heappush(open_set, (new_f, new_g, neighbor, path + [current_state]))

    return None  # No solution found


def get_user_input():
    
    while True:
        try:
            entries = list(map(int, input("Enter 9 space-separated numbers (0-8): ").split()))
            if len(entries) != 9 or sorted(entries) != list(range(9)):
                raise ValueError
            state = tuple(tuple(entries[i*3:(i+1)*3]) for i in range(3))
            return state
        except ValueError:
            print("Invalid input. Please enter numbers from 0 to 8 without duplicates.")


if __name__ == "__main__":
    start = get_user_input()
    solution = a_star(start)

    if solution:
        print(f"\n Solution found in {len(solution) - 1} moves:\n")
        for step_num, step in enumerate(solution):
            print(f"Step {step_num}:")
            print_state(step)
    else:
        print(" No solution found.")
